# rbm LL(2) grammar

Below I present LL(2) grammar for a b-minor language that is being used
by the `rbm` parser.

Things in angle brackets represent non-terminal symbol.
Unenclosed names represent terminal symbols. They reflect actual tokens.
!null! represents empty string.

```text
<PROGRAM> -> <DECLARATION>*
<DECLARATION> -> <DECLARATION_BEGINNING>
<DECLARATION_BEGINING> -> IDENTIFIER COLON <FULL_TYPE> <DECLARATION_ASSIGNMENT>
<!---
You need to check what is they keyword after COLON to decide on which
<DECLERATION_ASSIGNMENT> wil be used after parsing <FULL_TYPE>.
-->
<DECLARATION_ASSIGNMENT> -> `if_function` EQUAL <BLOCK_STATEMENT>
<DECLARATION_ASSIGNMENT> -> `if_identifier` <EXPRESSION> SEMICOLON
<DECLARATION_ASSIGNMENT> -> `if_array` <EXPRESSION> SEMICOLON
<DECLARATION_ASSIGNMENT> -> SEMICOLON

<STATEMENT> -> <ASSIGNMENT_STATEMENT>
            |  <DECLARATION_STATEMENT>
            |  <EXPRESSION_STATEMENT>
            |  <IF_ELSE_STATEMENT>
            |  <FOR_STATEMENT>
            |  <PRINT_STATEMENT>
            |  <RETURN_STATEMENT>
            |  <BLOCK_STATEMENT>

<ASSIGNMENT_STATEMENT> -> <EXPRESSION> EQUAL <EXPRESSION> SEMICOLON
<DECLARATION_STATEMENT> -> <DECLARATION>
<IF_ELSE_STATEMENT> -> <IF> <ELSE>
<IF> -> IF OPEN_PAREN <EXPRESSION> CLOSE_PAREN <STATEMENT>
<ELSE> -> ELSE OPEN_PAREN <EXPRESSION> CLOSE_PAREN <STATEMENT>
<ELSE> -> !null!

<EXPRESSION_STATEMENT> -> <EXPRESSION>
<FOR_STATEMENT> -> FOR OPEN_PAREN
                   <EXPRESSION> SEMICOLON
                   <EXPRESSION> SEMICOLON
                   <EXPRESSION>
                   CLOSE_PAREN <CODE_BLOCK>
                | FOR OPEN_PAREN SEMICOLON SEMICOLON CLOSE_PAREN <CODE_BLOCK>

<PRINT_STATEMENT> -> PRINT (<EXPRESSION>)? (COMMA <EXPRESSION>)* SEMICOLON
<RETURN_STATEMENT> -> RETURN <EXPRESSION> SEMICOLON
<BLOCK_STATEMENT> -> OPEN_BRACKET <STATEMENT>* CLOSE_BRACKET

<EXPRESSION> -> <ASSIGNMENT>
<ASSIGNMENT> -> <LOGICAL> <ASSIGNMENT'>
<ASSIGNMENT'> -> EQUAL <LOGICAL> <ASSIGNMENT'>
<ASSIGNMENT'> -> !null!

<LOGICAL> -> <COMPARISON> <LOGICAL'>
<LOGICAL'> -> PIPE PIPE <COMPARISON> <LOGICAL'>
<LOGICAL'> -> AMPERSAND AMPERSAND <COMPARISON> <LOGICAL'>
<LOGICAL'> -> !null!

<COMPARISON> -> <ARITHMETICAL_ADD_SUB> <COMPARISON'>
<COMPARISON'> -> OPEN_ANGLE <COMPARISON'OPEN_ANGLE>
<COMPARISON'> -> CLOSE_ANGLE <COMPARISON'CLOSE_ANGLE>
<COMPARISON'> -> EQUAL EQUAL <ARITHMETICAL_ADD_SUB> <COMPARISON'>
<COMPARISON'> -> EXCLEMATION EQUAL <ARITHMETICAL_ADD_SUB> <COMPARISON'>
<COMPARISON'> -> !null!
<COMPARISON'OPEN_ANGLE> -> <ARITHMETICAL_ADD_SUB> <COMPARISON'>
<COMPARISON'OPEN_ANGLE> -> EQUAL <ARITHMETICAL_ADD_SUB> <COMPARISON'>
<COMPARISON'CLOSE_ANGLE> -> <ARITHMETICAL_ADD_SUB> <COMPARISON'>
<COMPARISON'CLOSE_ANGLE> -> EQUAL <ARITHMETICAL_ADD_SUB> <COMPARISON'>


<ARITHMETICAL_ADD_SUB> -> <ARITHMETICAL_MUL_DIV_MOD> <ARITHMETICAL_ADD_SUB'>
<ARITHMETICAL_ADD_SUB'> -> PLUS <ARITHMETICAL_MUL_DIV_MOD> <ARITHMETICAL_ADD_SUB'>
<ARITHMETICAL_ADD_SUB'> -> MINUS <ARITHMETICAL_MUL_DIV_MOD> <ARITHMETICAL_ADD_SUB'>
<ARITHMETICAL_ADD_SUB'> -> !null!

<ARITHMETICAL_MUL_DIV_MOD> -> <EXPONENTIATION> <ARITHMETICAL_MUL_DIV_MOD'>
<ARITHMETICAL_MUL_DIV_MOD'> -> STAR <EXPONENTIATION> <ARITHMETICAL_MUL_DIV_MOD'>
<ARITHMETICAL_MUL_DIV_MOD'> -> SLASH <EXPONENTIATION> <ARITHMETICAL_MUL_DIV_MOD'>
<ARITHMETICAL_MUL_DIV_MOD'> -> PERCENT <EXPONENTIATION> <ARITHMETICAL_MUL_DIV_MOD'>
<ARITHMETICAL_MUL_DIV_MOD'> -> !null!

<EXPONENTIATION> -> <UNARY> <EXPONENTIATION'>
<EXPONENTIATION'> -> DASH <UNARY> <EXPONENTIATION'>
<EXPONENTIATION'> -> !null!

<UNARY> -> <POSTFIX> <UNARY'>
<UNARY'> -> MINUS <POSTFIX> <UNARY'>
<UNARY'> -> EXCLEMATION <POSTFIX> <UNARY'>
<UNARY'> -> !null!

<UNARY> ->  <UNARY'> <POSTFIX>
<UNARY'> -> MINUS <UNARY'>
<UNARY'> -> EXCLEMATION <UNARY'>
<UNARY'> -> !null!

<POSTFIX> -> <SUBSCRIPT_CALL> <POSTFIX'>
<POSTFIX'> -> PLUS PLUS <POSTFIX'>
<POSTFIX'> -> MINUS MINUS <POSTFIX'>
<POSTFIX'> -> !null!

<SUBSCRIPT_CALL> -> <VALUE> <SUBSCRIPT_CALL'>
<SUBSCRIPT_CALL'> -> OPEN_PAREN <FUNCTION_ARGUMENTS> CLOSE_PAREN <SUBSCRIPT_CALL'>
<SUBSCRIPT_CALL'> -> OPEN_BRACKET <EXPRESSION> CLOSE_BRACKET <SUBSCRIPT_CALL'>
<SUBSCRIPT_CALL'> -> !null!

<VALUE> -> IDENTIFIER | FLOAT | INTEGER | CHARACTER | TEXT
<VALUE> -> OPEN_BRACE (<EXPRESSION> (COMMA <EXPRESSION>)*)? CLOSE_BRACE
<VALUE> -> OPEN_PAREN <EXPRESSION> CLOSE_PAREN

<ID_PARAMETER> -> IDENTIFIER COLON <EMPTY_TYPE>
<NON_ID_PARAMETER> -> <EMPTY_TYPE>

<FUNCTION_ARGUMENTS> -> (<EXPRESSION> COMMA)*
<FUNCTION_ID_PARAMETERS> -> OPEN_PAREN (<ID_PARAMETER>)?
                            (COMMA <ID_PARAMETER>)* CLOSE_PAREN
<FUNCTION_NON_ID_PARAMETERS> -> OPEN_PAREN (<NON_ID_PARAMETER>)?
                                (COMMA <NON_ID_PARAMETER>)* CLOSE_PAREN


<FULL_TYPE> -> IDENTIFIER
<FULL_TYPE> -> ARRAY_KEYWORD OPEN_BRACKET INTEGER CLOSE_BRACKET <FULL_TYPE>
<FULL_TYPE> -> FUNCTION_KEYWORD <EMPTY_TYPE> <FUNCTION_ID_PARAMATERS>

<EMPTY_TYPE> -> IDENTIFIER
<EMPTY_TYPE> -> ARRAY_KEYWORD OPEN_BRACKET CLOSE_BRACKET <EMPTY_TYPE>
<EMPTY_TYPE> -> FUNCTION_KEYWORD <EMPTY_TYPE> <FUNCTION_NON_ID_PARAMATERS>

<LITERAL> -> FLOAT | INTEGER | CHARACTER | TEXT
```
